# Strategy Team & Optimization Agent Flow Analysis

## Overview
This document details the flow, expectations, and data schemas of the Strategy Team agents and the Optimization Agent in the FuegoRecommender system. It is based on the orchestration logic, agent implementations, and schema definitions.

---

## 1. Strategy Team: Flow, Inputs, and Outputs

### Where the Strategy Team is Orchestrated
- **File:** `src/orchestrator.py`
- **Key Function:** `run_strategy_loop(session_state, strategy_agents_with_proxy, llm_config)`
- **Agent Definitions:** `src/agents/strategy_team/strategy_team_agents.py` (via `get_strategy_team_agents`)

### Agents Involved
- **StrategistAgent**: Validates features from a business/strategy perspective.
- **EngineerAgent**: Validates features from a technical perspective.
- **FeatureEngineer**: Realizes features from candidate specs (merges ideation & realization).
- **UserProxy_Strategy**: Executes code and manages tool calls (e.g., saving candidate features).

### Inputs to the Strategy Team
- **Session State**: Contains hypotheses generated by the Discovery Team, candidate features, and DB schema.
- **LLM Config**: Language model configuration for all agents.
- **Database Schema**: Injected into prompts for context.

#### Typical Flow
1. **Initialization**: Agents are created with system prompts (Jinja2 templates) and provided with the DB schema.
2. **Group Chat**: Agents collaborate in a group chat (via `SmartGroupChatManager`), discussing and refining feature ideas.
3. **Feature Proposal**: Candidate features are proposed using the `save_candidate_features` tool (schema-enforced, see below).
4. **Feature Realization**: The `FeatureEngineer` agent (or `FeatureRealizationAgent`) generates executable code for each candidate feature, validates, and registers it.
5. **Outputs**: The session state's `features` and `realized_features` fields are updated, ready for downstream optimization.

#### save_candidate_features Tool Schema
- **Fields:**
  - `candidate_features_data`: List of dicts, each with:
    - `name`: Unique, snake_case name
    - `description`: Explanation
    - `dependencies`: List of source column names
    - `parameters`: Dict of tunable parameters (name: {type, description})

### Outputs from the Strategy Team
- **Realized Features**: List of validated, executable feature code objects (see `RealizedFeature` schema).
- **Session State Updates**: `features`, `realized_features`, and possibly logs/reports.

---

## 2. Optimization Agent (VULCANOptimizer): Inputs & Flow

### File: `src/agents/strategy_team/optimization_agent_v2.py`

#### Required Inputs
- **features**: List of realized feature dicts (as per `RealizedFeature` schema).
- **n_trials**: Number of optimization trials.
- **use_fast_mode**: Whether to subsample data for speed.
- **session**: SessionState object (tracks run context, logs, etc.).
- **data_dir, db_path**: Paths to data and database.

#### Optimization Process Flow
1. **Initialization**: Sets up data manager, logging, and (optionally) TensorBoard.
2. **Parameter Sampling**: For each trial, samples feature parameters (using Optuna for Bayesian optimization).
3. **K-Fold Cross-Validation**: Splits data, generates feature matrices, and trains LightFM models per fold.
4. **Evaluation**: Computes metrics (e.g., NDCG, Precision, Recall) per fold/trial.
5. **Pruning & Early Stopping**: Uses Optuna's pruning to terminate poor trials early.
6. **Result Aggregation**: Tracks best parameters, scores, and feature importances.
7. **Output**: Returns an `OptimizationResult` object (see below).

#### Output: OptimizationResult Schema
- **best_params**: Dict of best hyperparameters found.
- **best_score**: Best (mean) score achieved.
- **trial_results**: List of dicts with detailed trial info.
- **feature_importances**: Dict mapping feature names to importance scores.

---

## 3. Key Data Schemas (from `src/schemas/models.py`)

### CandidateFeature
- `name`: str
- `type`: Literal["code"]
- `spec`: str (Python logic)
- `depends_on`: List[str]
- `parameters`: Dict[str, ParameterSpec]
- `rationale`: str

### RealizedFeature
- `name`: str
- `code_str`: str (Python function)
- `parameters`: Dict[str, ParameterSpec]
- `passed_test`: bool
- `type`: Literal["code"]
- `source_candidate`: CandidateFeature

### ParameterSpec
- `type`: Literal["int", "float", "categorical"]
- `low`, `high`, `step`, `log`, `choices`, `default`: Optional fields

### OptimizationResult (from `optimization_agent_v2.py`)
- `best_params`: Dict[str, Any]
- `best_score`: float
- `trial_results`: List[Dict[str, Any]]
- `feature_importances`: Dict[str, float]

---

## 4. Summary Table
| Stage              | Input(s)                                        | Output(s)                                 | Key Schema(s)         |
|--------------------|-------------------------------------------------|-------------------------------------------|-----------------------|
| Strategy Team      | Hypotheses, DB schema, session state            | Realized features, session updates        | CandidateFeature, RealizedFeature |
| Optimization Agent | Realized features, n_trials, session, data_dir  | OptimizationResult                        | RealizedFeature, OptimizationResult |

---

## 5. Additional Notes
- The Strategy Team's flow is designed for modularity: new agents or tools can be added via prompt templates and schema definitions.
- The entire pipeline is orchestrated in `orchestrator.py`, which manages transitions between discovery, strategy, and optimization phases.
- All schemas are enforced using Pydantic for robustness.

---

*Generated automatically by Cascade AI on 2025-06-17.*
