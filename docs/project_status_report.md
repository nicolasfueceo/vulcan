# Project Status Report: Self-Improving Feature Engineering Pipeline

**Date:** 2023-10-27

This document provides a comprehensive overview of the current state of the self-improving, multi-agent feature engineering pipeline. It details the project's architecture, the roles and responsibilities of each agent, the prompts that guide them, and the overall workflow.

## 1. High-Level Architecture & Goal

The primary goal of this project is to create a fully autonomous, multi-agent system that can continuously discover, create, and refine features for a machine learning model. The system is designed as a closed loop, where insights from one cycle are used to inform the next, leading to continuous improvement.

The pipeline is orchestrated by a central `Orchestrator` that coordinates a team of specialized agents, each responsible for a specific stage of the research and development lifecycle:

1.  **Research & Hypothesis:** The `ResearchAgent` explores the data and generates initial hypotheses.
2.  **Ideation:** The `FeatureIdeationAgent` brainstorms potential features based on these hypotheses.
3.  **Realization:** The `FeatureRealizationAgent` turns these ideas into executable code.
4.  **Optimization:** The `OptimizationAgent` tunes the parameters of the new features.
5.  **Reflection:** The `ReflectionAgent` analyzes the results and suggests improvements for the next cycle.

All agents communicate and share their findings through a central, structured JSON file: `runtime/project_memory.json`.

## 2. Project Structure

The project is organized into the following directories:

-   `config/`: Contains all project configurations, such as API keys.
-   `data/`: A placeholder for the raw data files.
-   `docs/`: Contains project documentation, including this report.
-   `prompts/`: Contains the text-based prompts used to guide the LLM-powered agents.
-   `runtime/`: Contains all files generated during the pipeline's execution, including the `project_memory.json` file and any generated code.
-   `src/`: Contains all the Python source code for the project.
    -   `src/agents/`: Contains the implementation of each specialized agent.
    -   `src/scripts/`: Contains the main entry point for the application.
    -   `src/utils/`: Contains shared utility functions.
-   `tests/`: Contains all the end-to-end tests for the agents and the orchestrator.

## 3. Agent Roles & Responsibilities

### 3.1. ResearchAgent

-   **File:** `src/agents/research_agent.py`
-   **Role:** To perform initial exploratory data analysis (EDA) and generate hypotheses.
-   **Implementation:** This agent is a multi-agent `GroupChat` managed by Autogen. It consists of a `Data_Analyst` agent that writes Python code for analysis, a `User_Proxy` that executes the code, and a `Data_Scientist` that interprets the results and formulates hypotheses.
-   **Prompts:**
    -   **Data_Analyst:** "You are a senior data analyst. Your role is to perform detailed data analysis using Python. Given a task, write Python code to analyze the provided pandas DataFrame. Your code should be executable in a Jupyter environment. Do not offer analysis or interpretations, only code. IMPORTANT: After your code block, on a new line, write the word TERMINATE to end your turn. Do not write TERMINATE inside the code block."
    -   **Data_Scientist:** "You are a data scientist. Your role is to interpret the results of data analysis, generate insights, and propose new hypotheses. You will be given the results of a data analysis task and are expected to provide a summary of insights and suggest next steps. When you are done, on a new line, write the word TERMINATE to end your turn."
-   **Access:** Reads the raw data and writes its findings (hypotheses) to the `hypotheses` section of `project_memory.json`.

### 3.2. FeatureIdeationAgent

-   **File:** `src/agents/feature_ideation_agent.py`
-   **Role:** To brainstorm potential features based on the hypotheses generated by the `ResearchAgent`.
-   **Implementation:** This agent uses a single `AssistantAgent` from Autogen to generate feature ideas in a two-pass process. It uses function calling to ensure its output is always valid JSON.
-   **Prompts:**
    -   **Pass 1 (Creativity):** See `prompts/ideation_pass1_prompt.txt`
    -   **Pass 2 (Refinement):** See `prompts/ideation_pass2_prompt.txt`
-   **Access:** Reads from the `hypotheses` section of memory and writes to the `feature_proposals` section.

### 3.3. FeatureRealizationAgent

-   **File:** `src/agents/feature_realization_agent.py`
-   **Role:** To convert the feature ideas from the `FeatureIdeationAgent` into executable Python functions.
-   **Implementation:** This agent uses an LLM to translate a domain-specific language (DSL) for features into a single line of Python code, which it then wraps in a full function definition. It validates the generated code using `exec`.
-   **Prompt:** See `prompts/realization_prompt.txt`
-   **Access:** Reads from the `feature_proposals` section of memory and writes to the `realized_functions` section.

### 3.4. OptimizationAgent

-   **File:** `src/agents/optimization_agent.py`
-   **Role:** To tune the parameters of the newly created features using Bayesian optimization.
-   **Implementation:** This agent uses the `scikit-optimize` library to perform Bayesian optimization. It dynamically builds a search space from the realized functions and uses a dummy objective function that returns a random score (to be replaced with a real model).
-   **Access:** Reads from the `realized_functions` section of memory and writes to the `bo_history` section.

### 3.5. ReflectionAgent

-   **File:** `src/agents/reflection_agent.py`
-   **Role:** To analyze the results of the optimization process and provide insights and suggestions for the next cycle.
-   **Implementation:** This agent uses an LLM to analyze the `bo_history` and the weights of a (mock) trained model. It uses function calling to ensure its output is always valid JSON.
-   **Prompt:** See `prompts/reflection_prompt.txt`
-   **Access:** Reads from the `bo_history` section of memory and writes to the `reflections` section.

## 4. Current Status & Next Steps

The project is in a good state. All agents have been implemented and tested individually, and the orchestrator is in place to run a full cycle of the pipeline. The project structure has been refactored for better organization and maintainability.

The immediate next steps are:
1.  **Fix the `ModuleNotFoundError`** that is preventing the pipeline from running. This is a simple pathing issue that needs to be corrected.
2.  **Implement a real objective function** in the `OptimizationAgent`. This will involve training a simple model (like a Factorization Machine) and using its performance (e.g., RMSE) as the optimization target.
3.  **Integrate real data** into the pipeline. The agents are currently running with dummy data and simple tasks.
4.  **Implement the "infinite loop"** in the orchestrator, allowing the system to run continuously and improve itself over time.

This project has a solid foundation and is well on its way to achieving its ambitious goal of a truly self-improving feature engineering pipeline. 